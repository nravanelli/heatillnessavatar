{
  "version": 3,
  "sources": ["../../vuetify/src/components/VRangeSlider/VRangeSlider.tsx"],
  "sourcesContent": ["// Styles\nimport '../VSlider/VSlider.sass'\n\n// Components\nimport { makeVInputProps, VInput } from '@/components/VInput/VInput'\nimport { VLabel } from '@/components/VLabel'\nimport { getOffset, makeSliderProps, useSlider, useSteps } from '@/components/VSlider/slider'\nimport { VSliderThumb } from '@/components/VSlider/VSliderThumb'\nimport { VSliderTrack } from '@/components/VSlider/VSliderTrack'\n\n// Composables\nimport { makeFocusProps, useFocus } from '@/composables/focus'\nimport { useRtl } from '@/composables/locale'\nimport { useProxiedModel } from '@/composables/proxiedModel'\n\n// Utilities\nimport { computed, ref } from 'vue'\nimport { genericComponent, propsFactory, useRender } from '@/util'\n\n// Types\nimport type { PropType, WritableComputedRef } from 'vue'\nimport type { VSliderSlots } from '../VSlider/VSlider'\n\nexport const makeVRangeSliderProps = propsFactory({\n  ...makeFocusProps(),\n  ...makeVInputProps(),\n  ...makeSliderProps(),\n\n  strict: Boolean,\n  modelValue: {\n    type: Array as PropType<readonly (string | number)[]>,\n    default: () => ([0, 0]),\n  },\n}, 'VRangeSlider')\n\nexport const VRangeSlider = genericComponent<VSliderSlots>()({\n  name: 'VRangeSlider',\n\n  props: makeVRangeSliderProps(),\n\n  emits: {\n    'update:focused': (value: boolean) => true,\n    'update:modelValue': (value: [number, number]) => true,\n    end: (value: [number, number]) => true,\n    start: (value: [number, number]) => true,\n  },\n\n  setup (props, { slots, emit }) {\n    const startThumbRef = ref<VSliderThumb>()\n    const stopThumbRef = ref<VSliderThumb>()\n    const inputRef = ref<VInput>()\n    const { rtlClasses } = useRtl()\n\n    function getActiveThumb (e: MouseEvent | TouchEvent) {\n      if (!startThumbRef.value || !stopThumbRef.value) return\n\n      const startOffset = getOffset(e, startThumbRef.value.$el, props.direction)\n      const stopOffset = getOffset(e, stopThumbRef.value.$el, props.direction)\n\n      const a = Math.abs(startOffset)\n      const b = Math.abs(stopOffset)\n\n      return (a < b || (a === b && startOffset < 0)) ? startThumbRef.value.$el : stopThumbRef.value.$el\n    }\n\n    const steps = useSteps(props)\n\n    const model = useProxiedModel(\n      props,\n      'modelValue',\n      undefined,\n      arr => {\n        if (!arr?.length) return [0, 0]\n\n        return arr.map(value => steps.roundValue(value))\n      },\n    ) as WritableComputedRef<[number, number]> & { readonly externalValue: number[] }\n\n    const {\n      activeThumbRef,\n      hasLabels,\n      max,\n      min,\n      mousePressed,\n      onSliderMousedown,\n      onSliderTouchstart,\n      position,\n      trackContainerRef,\n      readonly,\n    } = useSlider({\n      props,\n      steps,\n      onSliderStart: () => {\n        emit('start', model.value)\n      },\n      onSliderEnd: ({ value }) => {\n        const newValue: [number, number] = activeThumbRef.value === startThumbRef.value?.$el\n          ? [value, model.value[1]]\n          : [model.value[0], value]\n\n        if (!props.strict && newValue[0] < newValue[1]) {\n          model.value = newValue\n        }\n\n        emit('end', model.value)\n      },\n      onSliderMove: ({ value }) => {\n        const [start, stop] = model.value\n\n        if (!props.strict && start === stop && start !== min.value) {\n          activeThumbRef.value = value > start ? stopThumbRef.value?.$el : startThumbRef.value?.$el\n          activeThumbRef.value?.focus()\n        }\n\n        if (activeThumbRef.value === startThumbRef.value?.$el) {\n          model.value = [Math.min(value, stop), stop]\n        } else {\n          model.value = [start, Math.max(start, value)]\n        }\n      },\n      getActiveThumb,\n    })\n\n    const { isFocused, focus, blur } = useFocus(props)\n    const trackStart = computed(() => position(model.value[0]))\n    const trackStop = computed(() => position(model.value[1]))\n\n    useRender(() => {\n      const inputProps = VInput.filterProps(props)\n      const hasPrepend = !!(props.label || slots.label || slots.prepend)\n\n      return (\n        <VInput\n          class={[\n            'v-slider',\n            'v-range-slider',\n            {\n              'v-slider--has-labels': !!slots['tick-label'] || hasLabels.value,\n              'v-slider--focused': isFocused.value,\n              'v-slider--pressed': mousePressed.value,\n              'v-slider--disabled': props.disabled,\n            },\n            rtlClasses.value,\n            props.class,\n          ]}\n          style={ props.style }\n          ref={ inputRef }\n          { ...inputProps }\n          focused={ isFocused.value }\n        >\n          {{\n            ...slots,\n            prepend: hasPrepend ? slotProps => (\n              <>\n                { slots.label?.(slotProps) ?? (\n                  props.label\n                    ? (\n                      <VLabel\n                        class=\"v-slider__label\"\n                        text={ props.label }\n                      />\n                    ) : undefined\n                )}\n\n                { slots.prepend?.(slotProps) }\n              </>\n            ) : undefined,\n            default: ({ id, messagesId }) => (\n              <div\n                class=\"v-slider__container\"\n                onMousedown={ !readonly.value ? onSliderMousedown : undefined }\n                onTouchstartPassive={ !readonly.value ? onSliderTouchstart : undefined }\n              >\n                <input\n                  id={ `${id.value}_start` }\n                  name={ props.name || id.value }\n                  disabled={ !!props.disabled }\n                  readonly={ !!props.readonly }\n                  tabindex=\"-1\"\n                  value={ model.value[0] }\n                />\n\n                <input\n                  id={ `${id.value}_stop` }\n                  name={ props.name || id.value }\n                  disabled={ !!props.disabled }\n                  readonly={ !!props.readonly }\n                  tabindex=\"-1\"\n                  value={ model.value[1] }\n                />\n\n                <VSliderTrack\n                  ref={ trackContainerRef }\n                  start={ trackStart.value }\n                  stop={ trackStop.value }\n                >\n                  {{ 'tick-label': slots['tick-label'] }}\n                </VSliderTrack>\n\n                <VSliderThumb\n                  ref={ startThumbRef }\n                  aria-describedby={ messagesId.value }\n                  focused={ isFocused && activeThumbRef.value === startThumbRef.value?.$el }\n                  modelValue={ model.value[0] }\n                  onUpdate:modelValue={ v => (model.value = [v, model.value[1]]) }\n                  onFocus={ (e: FocusEvent) => {\n                    focus()\n                    activeThumbRef.value = startThumbRef.value?.$el\n\n                    // Make sure second thumb is focused if\n                    // the thumbs are on top of each other\n                    // and they are both at minimum value\n                    // but only if focused from outside.\n                    if (\n                      max.value !== min.value &&\n                      model.value[0] === model.value[1] &&\n                      model.value[1] === min.value &&\n                      e.relatedTarget !== stopThumbRef.value?.$el\n                    ) {\n                      startThumbRef.value?.$el.blur()\n                      stopThumbRef.value?.$el.focus()\n                    }\n                  }}\n                  onBlur={ () => {\n                    blur()\n                    activeThumbRef.value = undefined\n                  }}\n                  min={ min.value }\n                  max={ model.value[1] }\n                  position={ trackStart.value }\n                  ripple={ props.ripple }\n                >\n                  {{ 'thumb-label': slots['thumb-label'] }}\n                </VSliderThumb>\n\n                <VSliderThumb\n                  ref={ stopThumbRef }\n                  aria-describedby={ messagesId.value }\n                  focused={ isFocused && activeThumbRef.value === stopThumbRef.value?.$el }\n                  modelValue={ model.value[1] }\n                  onUpdate:modelValue={ v => (model.value = [model.value[0], v]) }\n                  onFocus={ (e: FocusEvent) => {\n                    focus()\n                    activeThumbRef.value = stopThumbRef.value?.$el\n\n                    // Make sure first thumb is focused if\n                    // the thumbs are on top of each other\n                    // and they are both at maximum value\n                    // but only if focused from outside.\n                    if (\n                      max.value !== min.value &&\n                      model.value[0] === model.value[1] &&\n                      model.value[0] === max.value &&\n                      e.relatedTarget !== startThumbRef.value?.$el\n                    ) {\n                      stopThumbRef.value?.$el.blur()\n                      startThumbRef.value?.$el.focus()\n                    }\n                  }}\n                  onBlur={ () => {\n                    blur()\n                    activeThumbRef.value = undefined\n                  }}\n                  min={ model.value[0] }\n                  max={ max.value }\n                  position={ trackStop.value }\n                  ripple={ props.ripple }\n                >\n                  {{ 'thumb-label': slots['thumb-label'] }}\n                </VSliderThumb>\n              </div>\n            ),\n          }}\n        </VInput>\n      )\n    })\n\n    return {}\n  },\n})\n\nexport type VRangeSlider = InstanceType<typeof VRangeSlider>\n"],
  "mappings": "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",
  "names": ["makeVRangeSliderProps", "propsFactory", "makeFocusProps", "makeVInputProps", "makeSliderProps", "strict", "Boolean", "modelValue", "type", "Array", "default", "VRangeSlider", "genericComponent", "name", "props", "emits", "value", "end", "start", "setup", "_ref", "slots", "emit", "startThumbRef", "ref", "stopThumbRef", "inputRef", "rtlClasses", "useRtl", "getActiveThumb", "e", "startOffset", "getOffset", "$el", "direction", "stopOffset", "a", "Math", "abs", "b", "steps", "useSteps", "model", "useProxiedModel", "undefined", "arr", "length", "map", "roundValue", "activeThumbRef", "hasLabels", "max", "min", "mousePressed", "onSliderMousedown", "onSliderTouchstart", "position", "trackContainerRef", "readonly", "useSlider", "onSliderStart", "onSliderEnd", "_ref2", "newValue", "onSliderMove", "_ref3", "stop", "focus", "isFocused", "blur", "useFocus", "trackStart", "computed", "trackStop", "useRender", "inputProps", "VInput", "filterProps", "hasPrepend", "label", "prepend", "_createVNode", "_mergeProps", "disabled", "class", "style", "slotProps", "_createElementVNode", "_Fragment", "VLabel", "_ref4", "id", "messagesId", "VSliderTrack", "VSliderThumb", "v", "relatedTarget", "onBlur", "ripple"]
}
